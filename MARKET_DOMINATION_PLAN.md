# ClipsCommerce: The Master Plan for Market Domination

**Last Updated:** July 3, 2025

## Table of Contents
1.  [Our Vision: The Indispensable Creator-Entrepreneur OS](#1-our-vision-the-indispensable-creator-entrepreneur-os)
2.  [The Market: A Converging Opportunity](#2-the-market-a-converging-opportunity)
3.  [The Unassailable Product: 7 Criteria for Market Dominance](#3-the-unassailable-product-7-criteria-for-market-dominance)
4.  [The Strategic Roadmap: A Phased Approach to Dominance](#4-the-strategic-roadmap-a-phased-approach-to-dominance)
    *   [Phase 1: The Micro-Influencer Flywheel (Q3 2025)](#phase-1-the-micro-influencer-flywheel-q3-2025)
    *   [Phase 2: The "Pulse" of Commerce (Q4 2025)](#phase-2-the-pulse-of-commerce-q4-2025)
    *   [Phase 3: The Network Effect (Q1 2026)](#phase-3-the-network-effect-q1-2026)
    *   [Phase 4: Expansion and Dominance (Q2 2026 and beyond)](#phase-4-expansion-and-dominance-q2-2026-and-beyond)
5.  [Success Metrics (KPIs)](#5-success-metrics-kpis)
6.  [Tactical Execution: Phases 1 & 2 - Accelerated Development Plan](#6-tactical-execution-phases-1--2---accelerated-development-plan)
    *   [Phase 1: The Micro-Influencer Flywheel (Q3 2025)](#phase-1-the-micro-influencer-flywheel-q3-2025-1)
        *   [Criterion 1: "Trend-to-Template" AI Engine (v1)](#criterion-1-trend-to-template-ai-engine-v1)
            *   [Sub-Task 1.1: Trend Identification Service (Backend)](#sub-task-11-trend-identification-service-backend)
            *   [Sub-Task 1.2: AI Template Generation (Backend)](#sub-task-12-ai-template-generation-backend)
            *   [Sub-Task 1.3: Frontend Integration (Trend-to-Template)](#sub-task-13-frontend-integration-trend-to-template)
        *   [Criterion 2: "One-Click" Commerce Integration (v1)](#criterion-2-one-click-commerce-integration-v1)
            *   [Sub-Task 2.1: Shopify Integration (Backend)](#sub-task-21-shopify-integration-backend)
            *   [Sub-Task 2.2: TikTok Shop Integration (Backend)](#sub-task-22-tiktok-shop-integration-backend)
            *   [Sub-Task 2.3: Frontend Integration (One-Click Commerce)](#sub-task-23-frontend-integration-one-click-commerce)
        *   [Criterion 4: The "Micro-Influencer" Flywheel](#criterion-4-the-micro-influencer-flywheel)
            *   [Sub-Task 4.1: Subscription Management (Backend)](#sub-task-41-subscription-management-backend)
            *   [Sub-Task 4.2: Usage-Based Limiting (Backend)](#sub-task-42-usage-based-limiting-backend)
            *   [Sub-Task 4.3: Frontend Integration (Micro-Influencer Flywheel)](#sub-task-43-frontend-integration-micro-influencer-flywheel)
    *   [Phase 2: The "Pulse" of Commerce (Q4 2025)](#phase-2-the-pulse-of-commerce-q4-2025-1)
        *   [Criterion 3: The Autoposting "Pulse"](#criterion-3-the-autoposting-pulse)
            *   [Sub-Task 3.1: Optimal Time Analysis (Backend)](#sub-task-31-optimal-time-analysis-backend)
            *   [Sub-Task 3.2: Intelligent Scheduling (Backend)](#sub-task-32-intelligent-scheduling-backend)
            *   [Sub-Task 3.3: Frontend Integration (Autoposting Pulse)](#sub-task-33-frontend-integration-autoposting-pulse)
        *   [Criterion 6: The "Performance" Dashboard](#criterion-6-the-performance-dashboard)
            *   [Sub-Task 6.1: Commerce-Focused Analytics (Backend)](#sub-task-61-commerce-focused-analytics-backend)
            *   [Sub-Task 6.2: Dashboard UI (Frontend)](#sub-task-62-dashboard-ui-frontend)
            *   [Sub-Task 6.3: Data Visualization (Frontend)](#sub-task-63-data-visualization-frontend)

---

## 1. Our Vision: The Indispensable Creator-Entrepreneur OS

Our vision is to become the indispensable operating system for the modern "creator-entrepreneur." We will achieve this by providing a seamless "idea-to-revenue" workflow that eliminates the friction between content creation, audience engagement, and commerce.

We are not just building a tool; we are building the engine of the creator economy.

## 2. The Market: A Converging Opportunity

Our target market exists at the intersection of three explosive trends:

*   **The Creator Economy:** A rapidly growing market of independent creators and entrepreneurs.
*   **Social Commerce:** The fusion of social media and e-commerce, with TikTok at the forefront.
*   **AI-driven Automation:** The use of artificial intelligence to automate and augment creative and business processes.

Our primary target audience is the **micro-influencer (1k-10k followers) who is actively trying to sell products on TikTok.** This is our beachhead market.

## 3. The Unassailable Product: 7 Criteria for Market Dominance

Our product strategy is defined by the following 7 criteria. These are not just features; they are the pillars of our value proposition.

1.  **The "Trend-to-Template" AI Engine:** Proactively identify viral trends and generate ready-to-use video templates.
2.  **"One-Click" Commerce Integration:** Seamlessly embed product links into AI-generated content for a frictionless "shoppertainment" experience.
3.  **The Autoposting "Pulse":** Intelligently schedule and publish content for maximum engagement and consistency.
4.  **The "Micro-Influencer" Flywheel:** Attract and grow with micro-influencers through an irresistible freemium or low-cost offering.
5.  **The "Authenticity" Watermark:** Augment, don't replace, the creator's unique brand and personality.
6.  **The "Performance" Dashboard:** Connect content to commerce with clear, actionable analytics that demonstrate ROI.
7.  **The "Community-Driven" Content Library:** Foster a network effect by allowing creators to share successful templates.

## 4. The Strategic Roadmap: A Phased Approach to Dominance

This roadmap synthesizes our previous planning documents and aligns them with our 7 criteria for market dominance.

### Phase 1: The Micro-Influencer Flywheel (Q3 2025)

*Goal: Capture the beachhead market and build the foundation for our flywheel.*

*   **Product Focus:**
    *   **Criterion 1: "Trend-to-Template" AI Engine (v1):** Develop the core AI engine to identify and templateize trending TikTok formats.
    *   **Criterion 2: "One-Click" Commerce Integration (v1):** Implement seamless integration with TikTok Shop and Shopify.
    *   **Criterion 4: The "Micro-Influencer" Flywheel:** Launch with a compelling freemium plan that is irresistible to our target audience.
*   **Marketing Focus:**
    *   **Launch Campaign:** Execute the launch plan outlined in `launch_copy.md`, with a clear and concise message: "We help you turn TikTok trends into sales."
    *   **Targeted Outreach:** Actively recruit a cohort of 100 micro-influencers to use the platform for free.

### Phase 2: The "Pulse" of Commerce (Q4 2025)

*Goal: Deepen our value proposition by automating the content lifecycle and proving ROI.*

*   **Product Focus:**
    *   **Criterion 3: The Autoposting "Pulse":** Launch the intelligent autoposting feature with optimal time recommendations and content queues.
    *   **Criterion 6: The "Performance" Dashboard:** Release the analytics dashboard that connects content to commerce.
*   **Marketing Focus:**
    *   **Case Studies:** Turn our initial cohort of micro-influencers into powerful case studies.
    *   **Performance Marketing:** Launch paid acquisition campaigns targeting micro-influencers on TikTok and Instagram.

### Phase 3: The Network Effect (Q1 2026)

*Goal: Build a defensible moat by fostering a community and a network effect.*

*   **Product Focus:**
    *   **Criterion 5: The "Authenticity" Watermark:** Enhance the AI engine to allow for greater customization and brand alignment.
    *   **Criterion 7: The "Community-Driven" Content Library:** Launch the shared template library.
*   **Marketing Focus:**
    *   **Community Building:** Launch a Discord or similar community for our users to share tips, tricks, and success stories.
    *   **Referral Program:** Launch a referral program that rewards users for bringing new creators to the platform.

### Phase 4: Expansion and Dominance (Q2 2026 and beyond)

*Goal: Expand our reach and solidify our position as the market leader.*

*   **Product Focus:**
    *   **Platform Expansion:** Add support for other social commerce platforms (e.g., Instagram Shopping, YouTube Shopping).
    *   **Virtual Influencers:** Explore the development of a virtual influencer creation engine, as outlined in the market research document.
*   **Marketing Focus:**
    *   **Strategic Partnerships:** Partner with creator economy platforms, marketing agencies, and e-commerce service providers.
    *   **Thought Leadership:** Position `clipscommerce` as the leading voice in the creator economy through content, research, and events.

## 5. Success Metrics (KPIs)

We will measure our success against the following key performance indicators:

*   **North Star Metric:** Weekly Active Creators
*   **Key Business Metrics:**
    *   Customer Acquisition Cost (CAC)
    *   Lifetime Value (LTV)
    *   Churn Rate
    *   Revenue Growth
*   **Key Product Metrics:**
    *   Trend-to-Template Conversion Rate
    *   Content-to-Commerce Conversion Rate
    *   Autoposting Adoption Rate
    *   Community Template Contribution Rate

This document will be reviewed and updated on a quarterly basis to reflect our progress and the evolving market landscape.

## 6. Tactical Execution: Phases 1 & 2 - Accelerated Development Plan

This section provides a highly detailed, agent-centric tactical breakdown for the execution of Phases 1 and 2. Each task is decomposed into atomic, parallelizable units, emphasizing Test-Driven Development (TDD), leveraging existing codebase context, and referencing relevant workflows and external resources.

### Phase 1: The Micro-Influencer Flywheel (Q3 2025)

*Goal: Capture the beachhead market and build the foundation for our flywheel.*

#### Criterion 1: "Trend-to-Template" AI Engine (v1)

*   **Current State:** Your `AIImprovementService` (`src/app/workflows/AI_improvement/services/AIImprovementService.ts`) is focused on reactive content analysis (sentiment, tone, etc.) and provides general AI suggestions (`src/components/ai-suggestions-card.tsx`). It can generate suggestions, but it doesn't proactively identify trends or generate video templates.

##### Sub-Task 1.1: Trend Identification Service (Backend)
*   **Agent Role:** Backend Agent, Data Agent
*   **Context Files:**
    *   `src/app/workflows/data_collection/lib/platforms/consolidated/TikTokClient.ts` (Reference for TikTok API interaction)
    *   `supabase/migrations/` (For new table schema)
    *   `src/lib/errors/errorHandling.ts` (For error handling patterns)
*   **Technical Steps:**
    1.  **TDD:** Write integration tests for `TrendHunterService` to ensure it can connect to TikTok, scrape/fetch trending data, and store it correctly in Supabase.
        *   *Agent Action (Test Agent):* Create `src/__tests__/services/TrendHunterService.test.ts`. Define mock TikTok API responses and expected Supabase interactions.
    2.  **Database Schema:** Define a new Supabase table `trending_templates` to store identified trends (e.g., `id`, `platform`, `trend_type` (hashtag, sound, format), `identifier` (e.g., hashtag string, sound ID), `metadata` (JSONB for popularity, associated videos, etc.), `last_updated`).
        *   *Agent Action (DevOps Agent):* Generate a new Supabase migration file (`supabase/migrations/YYYYMMDDHHMMSS_create_trending_templates_table.sql`).
    3.  **Service Implementation:** Create `src/services/TrendHunterService.ts`.
        *   Implement methods like `fetchTrendingHashtags()`, `fetchTrendingSounds()`, `fetchTrendingFormats()`.
        *   These methods will use the `TikTokClient` (or a new, more specific TikTok scraping utility) to gather data.
        *   Implement `saveTrendsToDb(trends: TrendData[])` to persist data.
        *   Consider rate limiting and error handling.
        *   *Agent Action (Backend Agent):* Implement the service logic, focusing on robust data fetching and storage.
    4.  **Scheduled Execution:** Implement a mechanism to run `TrendHunterService` periodically (e.g., daily).
        *   *Agent Action (DevOps Agent):* Configure a cron job or a serverless function (e.g., Vercel Cron Jobs) to trigger the service.
    5.  **Verification:** Run all new and existing tests. Ensure linting and type-checking pass.
*   **Parallelization:** Can run in parallel with Sub-Task 1.2 (AI Template Generation - initial setup) and Sub-Task 2.1 (Shopify Integration).
*   **Online References:**
    *   TikTok for Developers API: `https://developers.tiktok.com/` (for official APIs, though trending data might require creative solutions).
    *   Supabase documentation: `https://supabase.com/docs/guides/database/tables`
    *   Web scraping best practices (e.g., using `axios` and `cheerio` if direct API is insufficient).
*   **Workflow Reference:** `workflows/new-api-endpoint.md` (for backend service structure), `workflows/new-supabase-migration.md`

##### Sub-Task 1.2: AI Template Generation (Backend)
*   **Agent Role:** AI Agent, Backend Agent
*   **Context Files:**
    *   `src/app/workflows/AI_improvement/services/AIImprovementService.ts` (To extend)
    *   `src/lib/ai/openai-chat-types.ts` (Reference for AI types)
*   **Technical Steps:**
    1.  **TDD:** Write unit tests for the new `generateTemplateFromTrend` method, mocking the video generation API.
        *   *Agent Action (Test Agent):* Create `src/__tests__/services/AIImprovementService.test.ts` (or extend existing).
    2.  **Video Generation API Integration:** Research and select a video generation API (e.g., OpenAI Sora, RunwayML, Pika Labs). Obtain API keys.
        *   *Agent Action (AI Agent):* Investigate API capabilities and pricing.
    3.  **Service Extension:** Add a new method `generateTemplateFromTrend(trend: TrendData)` to `AIImprovementService`.
        *   This method will:
            *   Take a `TrendData` object (from `trending_templates`).
            *   Formulate a prompt for the video generation API based on the trend type and metadata.
            *   Call the video generation API.
            *   Store the generated video URL and any associated metadata (e.g., template ID, AI prompt used) in your Supabase `trending_templates` table or a new `video_templates` table.
        *   *Agent Action (Backend Agent):* Implement the API calls and data handling.
    4.  **Verification:** Run tests, linting, type-checking.
*   **Parallelization:** Can run in parallel with Sub-Task 1.1 (after initial `trending_templates` schema is defined) and Sub-Task 2.1 (Shopify Integration).
*   **Online References:**
    *   OpenAI Sora API (if available): `https://openai.com/sora`
    *   RunwayML API: `https://runwayml.com/`
    *   Pika Labs: `https://www.pika.art/`
*   **Workflow Reference:** `workflows/new-api-endpoint.md` (for backend service extension)

##### Sub-Task 1.3: Frontend Integration (Trend-to-Template)
*   **Agent Role:** Frontend Agent, UI/UX Agent
*   **Context Files:**
    *   `src/app/dashboard/page.tsx` (Likely dashboard entry point)
    *   `src/components/ai-suggestions-card.tsx` (Reference for card structure)
    *   `src/components/ui/card.tsx`, `src/components/ui/button.tsx` (Shadcn/ui components)
*   **Technical Steps:**
    1.  **TDD:** Write Playwright E2E tests for the new `TrendingTemplatesCard` to ensure it renders correctly and allows user interaction (selecting a template).
        *   *Agent Action (Test Agent):* Create `e2e/trending-templates.e2e.spec.ts`.
    2.  **Component Creation:** Create `src/components/TrendingTemplatesCard.tsx`.
        *   This component will fetch trending templates from a new API endpoint (e.g., `/api/trends/templates`).
        *   Display each template with a preview (if possible) and a "Use Template" button.
        *   *Agent Action (Frontend Agent):* Develop the React component, focusing on responsive design and user experience.
    3.  **API Endpoint:** Create a new Next.js API route (`src/app/api/trends/templates/route.ts`) that exposes the data from `trending_templates` table.
        *   *Agent Action (Backend Agent):* Implement the API route, fetching data from Supabase.
    4.  **Dashboard Integration:** Integrate `TrendingTemplatesCard` into the main dashboard page (`src/app/dashboard/page.tsx`).
    5.  **Template Selection Flow:** When a user clicks "Use Template," navigate them to a video editor interface, pre-populating it with the selected template.
    6.  **Verification:** Run E2E tests, unit tests, linting, type-checking. Manual UI review.
*   **Parallelization:** Can run in parallel with Sub-Task 1.1 (after API endpoint is defined) and Sub-Task 1.2 (after template generation is stable).
*   **Online References:**
    *   Next.js App Router API Routes: `https://nextjs.org/docs/app/building-your-application/routing/route-handlers`
    *   Shadcn/ui documentation: `https://ui.shadcn.com/docs`
*   **Workflow Reference:** `workflows/new-react-component.md`, `workflows/new-api-route.md`

#### **Criterion 2: "One-Click" Commerce Integration (v1)**

*   **Current State:** You have a `TikTokClient` (`src/app/workflows/data_collection/lib/platforms/consolidated/TikTokClient.ts`) primarily for data collection. There is no direct integration with TikTok Shop or Shopify for product management.

##### Sub-Task 2.1: Shopify Integration (Backend)
*   **Agent Role:** Backend Agent, Security Agent
*   **Context Files:**
    *   `src/services/` (For new service)
    *   `supabase/migrations/` (For new table schema)
    *   `src/lib/errors/errorHandling.ts`
*   **Technical Steps:**
    1.  **TDD:** Write integration tests for `ShopifyService` covering OAuth flow, product fetching, and error handling.
        *   *Agent Action (Test Agent):* Create `src/__tests__/services/ShopifyService.test.ts`.
    2.  **Database Schema:** Define a new Supabase table `user_shopify_stores` (to store `shop_id`, `access_token`, `user_id`) and `shopify_products` (to store `product_id`, `shop_id`, `title`, `description`, `price`, `image_url`, `product_url`, `metadata`).
        *   *Agent Action (DevOps Agent):* Generate new Supabase migration files.
    3.  **OAuth Implementation:** Implement the Shopify OAuth flow. This involves redirecting the user to Shopify for authorization and handling the callback to exchange the authorization code for an access token.
        *   *Agent Action (Backend Agent):* Implement the OAuth logic, ensuring secure storage of access tokens.
    4.  **Product Fetching:** Create `src/services/ShopifyService.ts` with methods like `connectStore(userId, shopUrl, accessToken)` and `fetchProducts(shopId)`.
        *   `fetchProducts` will use the Shopify Admin API to retrieve the user's product catalog and save it to `shopify_products` table.
        *   *Agent Action (Backend Agent):* Implement the service logic, focusing on API calls and data mapping.
    5.  **Verification:** Run tests, linting, type-checking.
*   **Parallelization:** Can run in parallel with Sub-Task 1.1 and Sub-Task 2.2 (initial setup).
*   **Online References:**
    *   Shopify Admin API: `https://shopify.dev/docs/api/admin-rest`
    *   Shopify OAuth: `https://shopify.dev/docs/apps/auth/oauth`
*   **Workflow Reference:** `workflows/new-api-endpoint.md`

##### Sub-Task 2.2: TikTok Shop Integration (Backend)
*   **Agent Role:** Backend Agent, Security Agent
*   **Context Files:**
    *   `src/app/workflows/data_collection/lib/platforms/consolidated/TikTokClient.ts` (To extend)
    *   `src/types/tiktokTypes.ts` (To extend with shop-specific types)
    *   `supabase/migrations/` (For new table schema if needed for shop data)
*   **Technical Steps:**
    1.  **TDD:** Write integration tests for `TikTokClient` extensions related to TikTok Shop API calls (e.g., product listing, order creation).
        *   *Agent Action (Test Agent):* Extend `src/__tests__/tiktok-client.spec.ts`.
    2.  **TikTok Shop API Access:** Apply for and gain access to the TikTok Shop API. This is a prerequisite and may involve a manual review process.
        *   *Agent Action (DevOps Agent/Business Dev):* Handle the application process.
    3.  **Client Extension:** Extend `src/app/workflows/data_collection/lib/platforms/consolidated/TikTokClient.ts` to include methods for TikTok Shop interactions.
        *   Methods like `listShopProducts(userId)`, `createShoppableVideo(videoData, productIds)`, `trackOrder(orderId)`.
        *   This will involve understanding TikTok Shop's specific API endpoints for product management and shoppable content creation.
        *   *Agent Action (Backend Agent):* Implement the new methods within the existing `TikTokClient`, ensuring proper authentication and error handling.
    4.  **Verification:** Run tests, linting, type-checking.
*   **Parallelization:** Can run in parallel with Sub-Task 2.1 (initial setup).
*   **Online References:**
    *   TikTok Shop Open Platform API: `https://open.tiktokapis.com/` (Look for Shop-specific documentation).
*   **Workflow Reference:** `workflows/new-api-endpoint.md`

##### Sub-Task 2.3: Frontend Integration (One-Click Commerce)
*   **Agent Role:** Frontend Agent, UI/UX Agent
*   **Context Files:**
    *   `src/app/dashboard/page.tsx`
    *   `src/components/` (For new components)
    *   Existing video editor component (if any, otherwise a new one will be needed)
*   **Technical Steps:**
    1.  **TDD:** Write Playwright E2E tests for the product selection and tagging flow within the video editor.
        *   *Agent Action (Test Agent):* Create `e2e/video-editor-commerce.e2e.spec.ts`.
    2.  **Product Selector Component:** Create `src/components/ProductSelector.tsx`.
        *   This component will fetch products from the user's connected Shopify store (via a new API endpoint, e.g., `/api/shopify/products`).
        *   Allow users to search, filter, and select products.
        *   *Agent Action (Frontend Agent):* Develop the React component, focusing on a user-friendly product browsing experience.
    3.  **Video Editor Enhancement:** Modify your existing video editor component (or create `src/components/VideoEditor.tsx` if it doesn't exist).
        *   Integrate `ProductSelector` into the editor interface.
        *   Enable functionality to associate selected products with the video being created. This might involve adding product IDs to the video metadata before publishing.
        *   *Agent Action (Frontend Agent):* Modify the video editor, ensuring seamless integration of product tagging.
    4.  **API Endpoints:** Create new Next.js API routes (`src/app/api/shopify/products/route.ts`, `src/app/api/tiktok/shoppable-video/route.ts`) to expose product data and handle shoppable video creation requests.
        *   *Agent Action (Backend Agent):* Implement these API routes, calling the `ShopifyService` and `TikTokClient` extensions.
    5.  **Verification:** Run E2E tests, unit tests, linting, type-checking. Manual UI review.
*   **Parallelization:** Can run in parallel with Sub-Task 2.1 and Sub-Task 2.2 (after API endpoints are defined).
*   **Online References:**
    *   React Hook Form (for form management): `https://react-hook-form.com/`
    *   Shadcn/ui for select/search components.
*   **Workflow Reference:** `workflows/new-react-component.md`, `workflows/new-api-route.md`

#### **Criterion 4: The "Micro-Influencer" Flywheel**

*   **Current State:** Your `PLAN.md` mentions a pricing overhaul, but no code for subscription management or usage limiting was found in the analyzed files.

##### Sub-Task 4.1: Subscription Management (Backend)
*   **Agent Role:** Backend Agent, Security Agent, DevOps Agent
*   **Context Files:**
    *   `src/services/` (For new service)
    *   `supabase/migrations/` (For new table schema)
    *   `next.config.js` (For Stripe webhook configuration)
*   **Technical Steps:**
    1.  **TDD:** Write integration tests for `SubscriptionService` covering user subscription, webhook handling, and plan changes.
        *   *Agent Action (Test Agent):* Create `src/__tests__/services/SubscriptionService.test.ts`.
    2.  **Stripe Setup:** Set up a Stripe account, configure products and pricing plans (Freemium, Lite, Pro).
        *   *Agent Action (DevOps Agent):* Configure Stripe dashboard.
    3.  **Database Schema:** Define new Supabase tables `user_subscriptions` (to store `user_id`, `stripe_customer_id`, `stripe_subscription_id`, `plan_id`, `status`, `current_period_end`) and `pricing_plans` (to store `id`, `name`, `description`, `price`, `features`).
        *   *Agent Action (DevOps Agent):* Generate new Supabase migration files.
    4.  **Service Implementation:** Create `src/services/SubscriptionService.ts`.
        *   Implement methods to:
            *   Create Stripe customer.
            *   Create Stripe checkout session for subscription.
            *   Handle Stripe webhooks (e.g., `checkout.session.completed`, `customer.subscription.updated`, `customer.subscription.deleted`) to update `user_subscriptions` table.
        *   *Agent Action (Backend Agent):* Implement the service logic, focusing on secure Stripe API interactions and webhook processing.
    5.  **API Endpoint:** Create a Next.js API route (`src/app/api/stripe/webhook/route.ts`) to receive Stripe webhooks.
        *   *Agent Action (Backend Agent):* Implement the webhook handler, ensuring signature verification.
    6.  **Verification:** Run tests, linting, type-checking.
*   **Parallelization:** Can run in parallel with Sub-Task 4.2 (initial setup).
*   **Online References:**
    *   Stripe Subscriptions: `https://stripe.com/docs/billing/subscriptions`
    *   Stripe Webhooks: `https://stripe.com/docs/webhooks`
*   **Workflow Reference:** `workflows/new-api-endpoint.md`

##### Sub-Task 4.2: Usage-Based Limiting (Backend)
*   **Agent Role:** Backend Agent, Data Agent
*   **Context Files:**
    *   `src/services/` (For new service)
    *   `supabase/migrations/` (For new table schema)
    *   `src/app/workflows/AI_improvement/services/AIImprovementService.ts` (To integrate with)
*   **Technical Steps:**
    1.  **TDD:** Write unit/integration tests for `UsageService` to ensure accurate tracking and limit enforcement.
        *   *Agent Action (Test Agent):* Create `src/__tests__/services/UsageService.test.ts`.
    2.  **Database Schema:** Define a new Supabase table `user_usage` (to store `user_id`, `metric_type` (e.g., 'video_generations'), `count`, `last_reset_date`).
        *   *Agent Action (DevOps Agent):* Generate new Supabase migration file.
    3.  **Service Implementation:** Create `src/services/UsageService.ts`.
        *   Implement methods like `recordUsage(userId, metricType)`, `getUsage(userId, metricType)`, `checkLimit(userId, metricType, limit)`.
        *   Integrate `recordUsage` into relevant backend functions (e.g., after a video is successfully generated by the AI engine).
        *   *Agent Action (Backend Agent):* Implement the service logic, focusing on atomic updates and efficient querying.
    4.  **Verification:** Run tests, linting, type-checking.
*   **Parallelization:** Can run in parallel with Sub-Task 4.1 (after initial schema is defined).
*   **Online References:**
    *   Supabase Row Level Security (RLS) for usage data: `https://supabase.com/docs/guides/auth/row-level-security`
*   **Workflow Reference:** `workflows/new-api-endpoint.md` (for backend service structure)

##### Sub-Task 4.3: Frontend Integration (Micro-Influencer Flywheel)
*   **Agent Role:** Frontend Agent, UI/UX Agent
*   **Context Files:**
    *   `src/app/dashboard/page.tsx`
    *   `src/components/` (For new components)
    *   `src/components/team-dashboard/ClientDetailView.tsx` (Reference for user/client data display)
*   **Technical Steps:**
    1.  **TDD:** Write Playwright E2E tests for the `PricingPage` and the subscription management flow in user settings.
        *   *Agent Action (Test Agent):* Create `e2e/pricing-and-subscription.e2e.spec.ts`.
    2.  **Pricing Page:** Create `src/app/pricing/page.tsx` (or similar).
        *   Display the different plans, features, and pricing.
        *   Include clear CTAs to subscribe/upgrade.
        *   *Agent Action (Frontend Agent):* Develop the pricing page, focusing on clarity and conversion.
    3.  **User Settings Integration:** Modify user settings page (`src/app/settings/page.tsx` or similar) to display current subscription status and usage.
        *   Allow users to manage their subscription (e.g., upgrade, cancel).
        *   Display current usage against their plan limits.
        *   *Agent Action (Frontend Agent):* Integrate subscription and usage data into the user settings UI.
    4.  **API Endpoints:** Create new Next.js API routes (`src/app/api/subscriptions/route.ts`, `src/app/api/usage/route.ts`) to expose subscription and usage data to the frontend.
        *   *Agent Action (Backend Agent):* Implement these API routes.
    5.  **Verification:** Run E2E tests, unit tests, linting, type-checking. Manual UI review.
*   **Parallelization:** Can run in parallel with Sub-Task 4.1 and Sub-Task 4.2 (after API endpoints are defined).
*   **Online References:**
    *   Next.js App Router pages: `https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts`
    *   Shadcn/ui for pricing cards.
*   **Workflow Reference:** `workflows/new-react-component.md`, `workflows/new-api-route.md`

### Phase 2: The "Pulse" of Commerce (Q4 2025)

*Goal: Deepen our value proposition by automating the content lifecycle and proving ROI.*

#### Criterion 3: The Autoposting "Pulse"

*   **Current State:** You have a basic `AutoPostingScheduler` (`src/components/team-dashboard/modules/AutoPostingScheduler.tsx`) and a `ContentQueue` (`src/services/autoposting.ts`). The `AutoPostingScheduler.tsx` component *simulates* AI-powered optimal time generation using `clientPreferences.optimalTimes`, but this is not based on real-time user data or a dedicated service. The "content queues" feature is not explicitly implemented.

##### Sub-Task 3.1: Optimal Time Analysis (Backend)
*   **Agent Role:** Data Agent, Backend Agent
*   **Context Files:**
    *   `src/app/workflows/data_collection/lib/platforms/consolidated/TikTokClient.ts` (To fetch user post data)
    *   `src/app/workflows/AI_improvement/services/AIImprovementService.ts` (Reference for analytics/prediction)
    *   `supabase/migrations/` (For new table to store optimal times)
*   **Technical Steps:**
    1.  **TDD:** Write unit/integration tests for `OptimalTimeService` to ensure accurate calculation of optimal posting times based on historical data.
        *   *Agent Action (Test Agent):* Create `src/__tests__/services/OptimalTimeService.test.ts`.
    2.  **Database Schema:** Define a new Supabase table `user_optimal_posting_times` (to store `user_id`, `platform`, `day_of_week`, `hour`, `engagement_score`, `last_calculated`).
        *   *Agent Action (DevOps Agent):* Generate new Supabase migration file.
    3.  **Service Implementation:** Create `src/services/OptimalTimeService.ts`.
        *   Implement `calculateOptimalTimes(userId, platform)`:
            *   Fetches user's historical post data and engagement metrics from TikTok (via `TikTokClient`).
            *   Analyzes engagement patterns by day of week and hour.
            *   Calculates an "engagement score" for each time slot.
            *   Stores the top optimal times in `user_optimal_posting_times`.
        *   Implement `getOptimalTimes(userId, platform)`.
        *   *Agent Action (Backend Agent):* Implement the service logic, focusing on data analysis and persistence.
    4.  **Scheduled Recalculation:** Implement a mechanism to periodically recalculate optimal times for active users.
        *   *Agent Action (DevOps Agent):* Configure a cron job or serverless function.
    5.  **Verification:** Run tests, linting, type-checking.
*   **Parallelization:** Can run in parallel with Sub-Task 3.2 (initial setup).
*   **Online References:**
    *   Data analysis in TypeScript (e.g., using simple array methods or a small utility library).
*   **Workflow Reference:** `workflows/new-api-endpoint.md`

##### Sub-Task 3.2: Intelligent Scheduling (Backend)
*   **Agent Role:** Backend Agent
*   **Context Files:**
    *   `src/services/autoposting.ts` (To enhance `AutopostingService`)
    *   `src/app/workflows/autoposting/AutoPostingScheduler.ts` (To enhance)
    *   `src/services/OptimalTimeService.ts` (To integrate with)
*   **Technical Steps:**
    1.  **TDD:** Write unit/integration tests for the enhanced `AutoPostingScheduler` and `AutopostingService` to ensure intelligent scheduling and content queue functionality.
        *   *Agent Action (Test Agent):* Extend `src/__tests__/services/autoposting.test.ts` and `src/__tests__/team-dashboard/AutoPostingScheduler.test.tsx` (for backend logic).
    2.  **Scheduler Enhancement:** Modify `src/app/workflows/autoposting/AutoPostingScheduler.ts`.
        *   When a user adds content to be scheduled, use `OptimalTimeService.getOptimalTimes()` to suggest the best posting slots.
        *   Implement a "content queue" mechanism: allow users to add multiple pieces of content to a queue, and the scheduler will automatically pick the next available optimal slot.
        *   *Agent Action (Backend Agent):* Implement the intelligent scheduling logic, prioritizing optimal times and managing the content queue.
    3.  **API Endpoints:** Create new Next.js API routes (`src/app/api/autoposting/schedule-intelligent/route.ts`, `src/app/api/autoposting/queue/route.ts`) to expose intelligent scheduling and content queue management.
        *   *Agent Action (Backend Agent):* Implement these API routes.
    4.  **Verification:** Run tests, linting, type-checking.
*   **Parallelization:** Can run in parallel with Sub-Task 3.1 (after `OptimalTimeService` is defined).
*   **Online References:**
    *   Job scheduling libraries (if needed for complex background tasks, though simple cron/serverless might suffice).
*   **Workflow Reference:** `workflows/new-api-endpoint.md`

##### Sub-Task 3.3: Frontend Integration (Autoposting Pulse)
*   **Agent Role:** Frontend Agent, UI/UX Agent
*   **Context Files:**
    *   `src/components/team-dashboard/modules/AutoPostingScheduler.tsx` (To enhance)
    *   `src/components/ui/calendar.tsx`, `src/components/ui/select.tsx` (Shadcn/ui components)
*   **Technical Steps:**
    1.  **TDD:** Write Playwright E2E tests for the updated `AutoPostingScheduler` component, covering optimal time display and content queue management.
        *   *Agent Action (Test Agent):* Extend `e2e/autopost.e2e.spec.ts`.
    2.  **Scheduler UI Update:** Modify `src/components/team-dashboard/modules/AutoPostingScheduler.tsx`.
        *   Display the optimal posting times fetched from the new API endpoint (`/api/optimal-times`).
        *   Implement a UI for users to add content to a queue and visualize its position.
        *   Allow users to override suggested times if desired.
        *   *Agent Action (Frontend Agent):* Update the React component, focusing on clear presentation of optimal times and intuitive queue management.
    3.  **API Endpoints:** Ensure the frontend consumes data from the new intelligent scheduling API routes.
    4.  **Verification:** Run E2E tests, unit tests, linting, type-checking. Manual UI review.
*   **Parallelization:** Can run in parallel with Sub-Task 3.1 and Sub-Task 3.2 (after API endpoints are defined).
*   **Online References:**
    *   React Date Picker libraries (if more advanced calendar UI is needed).
*   **Workflow Reference:** `workflows/new-react-component.md`

#### **Criterion 6: The "Performance" Dashboard**

*   **Current State:** You have an `AutoPostAnalytics` class (`src/app/workflows/autoposting/AutoPostAnalytics.ts`) that defines interfaces for post outcomes and reports, and can record/generate basic reports. The `ClientDetailView.tsx` component provides a generic client dashboard, but not a dedicated `PerformanceDashboard` focused on post-level commerce analytics. The `AutoPostAnalytics` class has an `roi` field, indicating an *intent* for commerce analytics, but the integration to *get* this data from TikTok Shop or Shopify is missing.

##### Sub-Task 6.1: Commerce-Focused Analytics (Backend)
*   **Agent Role:** Data Agent, Backend Agent
*   **Context Files:**
    *   `src/app/workflows/autoposting/AutoPostAnalytics.ts` (To extend)
    *   `src/services/ShopifyService.ts` (To integrate with)
    *   `src/app/workflows/data_collection/lib/platforms/consolidated/TikTokClient.ts` (To integrate with for TikTok Shop data)
    *   `supabase/migrations/` (For new tables to store commerce data)
*   **Technical Steps:**
    1.  **TDD:** Write unit/integration tests for `AutoPostAnalytics` extensions to ensure accurate calculation of commerce metrics (conversion rate, ROI).
        *   *Agent Action (Test Agent):* Extend `src/__tests__/autoposting.test.ts` (or create a new analytics-specific test file).
    2.  **Database Schema:** Define new Supabase tables `post_commerce_metrics` (to store `post_id`, `platform`, `product_id`, `clicks`, `conversions`, `revenue`, `timestamp`).
        *   *Agent Action (DevOps Agent):* Generate new Supabase migration file.
    3.  **Analytics Extension:** Modify `src/app/workflows/autoposting/AutoPostAnalytics.ts`.
        *   Add methods to:
            *   Fetch commerce data from Shopify (via `ShopifyService`) and TikTok Shop (via `TikTokClient` extensions).
            *   Correlate commerce data with specific posts.
            *   Calculate `conversionRate`, `ROI`, `costPerConversion`.
        *   *Agent Action (Backend Agent):* Implement the data fetching and calculation logic, focusing on accurate attribution.
    4.  **Data Ingestion:** Implement a mechanism to regularly ingest commerce data and associate it with posts.
        *   *Agent Action (DevOps Agent):* Configure a cron job or serverless function to pull data.
    5.  **Verification:** Run tests, linting, type-checking.
*   **Parallelization:** Can run in parallel with Sub-Task 6.2 (initial setup).
*   **Online References:**
    *   Attribution modeling concepts for marketing analytics.
*   **Workflow Reference:** `workflows/new-api-endpoint.md`

##### Sub-Task 6.2: Dashboard UI (Frontend)
*   **Agent Role:** Frontend Agent, UI/UX Agent
*   **Context Files:**
    *   `src/app/dashboard/page.tsx`
    *   `src/components/` (For new component)
    *   `src/components/team-dashboard/ClientDetailView.tsx` (Reference for dashboard structure)
*   **Technical Steps:**
    1.  **TDD:** Write Playwright E2E tests for the new `PerformanceDashboard` component to ensure it renders correctly and displays key metrics.
        *   *Agent Action (Test Agent):* Create `e2e/performance-dashboard.e2e.spec.ts`.
    2.  **Component Creation:** Create `src/components/PerformanceDashboard.tsx`.
        *   This component will fetch commerce-focused analytics data from a new API endpoint (e.g., `/api/analytics/commerce`).
        *   Display key metrics like total revenue, conversions, top-performing products/videos.
        *   *Agent Action (Frontend Agent):* Develop the React component, focusing on a clear and impactful presentation of business-critical data.
    3.  **API Endpoint:** Create a new Next.js API route (`src/app/api/analytics/commerce/route.ts`) that exposes the commerce analytics data from `AutoPostAnalytics`.
        *   *Agent Action (Backend Agent):* Implement the API route.
    4.  **Dashboard Integration:** Integrate `PerformanceDashboard` into the main dashboard page (`src/app/dashboard/page.tsx`).
    5.  **Verification:** Run E2E tests, unit tests, linting, type-checking. Manual UI review.
*   **Parallelization:** Can run in parallel with Sub-Task 6.1 (after API endpoint is defined).
*   **Online References:**
    *   Shadcn/ui for dashboard layouts and cards.
*   **Workflow Reference:** `workflows/new-react-component.md`, `workflows/new-api-route.md`

##### Sub-Task 6.3: Data Visualization (Frontend)
*   **Agent Role:** Frontend Agent, UI/UX Agent
*   **Context Files:**
    *   `src/components/PerformanceDashboard.tsx` (To enhance)
*   **Technical Steps:**
    1.  **TDD:** Write unit tests for the charting components to ensure data is rendered correctly.
        *   *Agent Action (Test Agent):* Create `src/__tests__/components/PerformanceDashboard.test.tsx` (or extend existing).
    2.  **Charting Library Integration:** Choose a charting library (e.g., Recharts, Chart.js, Nivo).
        *   *Agent Action (Frontend Agent):* Research and select the best library based on project needs and existing dependencies.
    3.  **Visualization Implementation:** Within `src/components/PerformanceDashboard.tsx`, implement various charts to visualize the commerce data.
        *   Examples: Revenue over time, conversions by product, top-performing videos by ROI.
        *   *Agent Action (Frontend Agent):* Implement the charts, ensuring they are interactive and provide clear insights.
    4.  **Verification:** Run tests, linting, type-checking. Manual UI review.
*   **Parallelization:** Can run in parallel with Sub-Task 6.1 and Sub-Task 6.2 (after data structure is defined).
*   **Online References:**
    *   Recharts: `https://recharts.org/en-US/`
    *   Chart.js: `https://www.chartjs.org/`
    *   Nivo: `https://nivo.rocks/`
*   **Workflow Reference:** `workflows/new-react-component.md`


